---
title: Representative Samples of Subject Covariates
author: José Bayoán Santiago Calderón
date: 2019-02-03
---

# Introduction

This is a comprehensive tutorial showing how to create a representative sample
of the civilian noninstitutional adult population for the United States by
race/ethnicity, age, weight, and height. It showcases the basic tools that can
be used to generate simulated data for PuMaS.jl.

# Population and Variables of Interest

- US Civilian noninstitutional population
- Sex (Male or Female)
- Race (Latino,
        Non-Hispanic Single Race White,
        Non-Hispanic Single Race Black or
        Non-Hispanic Single Race Asian)
- Age (18 - 85 years old)
- Height in inches
- Weight in pounds

# Housekeeping

First some housekeeping. Let's start by pulling in the packages we will be using in this tutorial.

```julia
using CSV, DataFrames, DataFramesMeta, Distributions, HTTP, InfoZIP, LazyJSON, Optim, StatsBase, StatsPlots
```

# Age, Race, and Sex

Sex and race are nominal variables which can be captured through a cross
table with the joint distributions. Age usually does not follow a typical
distribution (i.e., demographic pyramids). We can use Census data to obtain the
joint distributions of sex and race conditional on age which is a discrete
variable (in years old).

The first dataset we will work with is the

    Annual Estimates of the Resident Population by Sex, Single Year of Age,
     Race Alone or in Combination, and Hispanic Origin for the United States:
     April 1, 2010 to July 1, 2017
     Source: U.S. Census Bureau, Population Division
     Release Date: June 2018

[Metadata](https://api.census.gov/data/2017/pep/charage), [Codebook](https://www.census.gov/data/developers/data-sets/popest-popproj/popest/popest-vars.Vintage_2017.html)

We can obtain this dataset using the US Census API

```julia
cross_table =
    string("https://api.census.gov/data/", # Base URL
           "2017/", # Vintage 2017
           "pep/", # Population Estimates
           "charage?", # Characteristics by Single Year of Age
           "get=AGE,HISP,POP,RACE,SEX&", # Variables
           "for=us", # For the whole United States
           ) |>
    (url -> HTTP.request("GET", url)) |> # GET request
    (response -> response.status == 200 ? # Verify status code OK
                 String(response.body) : response.status) # Get body of response
```

We will now convert the string containing the data into a tabular representation.

```julia
@views function detailedtable(jsontext)
    # We obtain the variable names (suppress the geography)
    vars = Symbol.(collect(LazyJSON.parse(jsontext)[1][1:end - 1]))
    # For each record we obtain a NamedTuple with the values parsed
    parserow(val) = NamedTuple{Tuple(vars)}(parse.(Int, val[1:end - 1]))
    # Function to determine race
    # Latino if Hispanic
    # White if Single Race White (Non-Hispanic)
    # Black if Single Race Black (Non-Hispanic)
    # Asian if Single Race Asian (Non-Hispanic)
    function parserace(hisp, race)
        if hisp == 2
            output = "Latino"
        elseif race == 1
            output = "White"
        elseif race == 2
            output = "Black"
        elseif race == 4
            output = "Asian"
        end
        output
    end
    # Build a DataFrame with the data
    DataFrame(parserow.(LazyJSON.parse(jsontext)[2:end])) |>
    # Filter the data based on sex/age/ethnicity
    (data -> data[(data.SEX .∈ Ref(1:2)) .& # Male = 1, Female = 2
                  (data.AGE .∈ Ref(18:85)) .& # Subset ages 18-85 years old
                  ((data.HISP .== 2) .| # Hispanic = 2
                  # Not Hispanic and one of the select races
                  # White = 1, Black = 2, Asian = 4
                   (data.HISP .== 1) .& (data.RACE .∈ Ref([1, 2, 4]))), :]) |>
    # Clean sex and race
    (df -> @transform(df,
                      SEX = ifelse.(:SEX .== 1, "Male", "Female") |> categorical,
                      RACE = parserace.(:HISP, :RACE) |> categorical)) |>
    (df -> aggregate(groupby(df, [:SEX, :RACE, :AGE]), sum)) |> # Collapse Latino
    # Select and rename variables
    (df -> names!(df[[:SEX, :RACE, :AGE, :POP_sum]], [:sex, :race, :age, :count]))
end
```

```julia
cross_table = detailedtable(cross_table)
first(cross_table, 5)
```

We can now use the tidy dataset to generate the conditional probabilities.

We have three dimensions, (1) Age, (2) Race, and (3) Sex.

We can obtain the joint distribution between age and race by sex.

```julia
females = cross_table |>
    (data -> data[data.sex .== "Female", [:race, :age, :count]]) |>
    (df -> unstack(df, :race, :count)) |> # To wide
    (data -> Matrix(data[2:end])) |>
    (A -> A / sum(A)) # conditional joint probabilities
males = cross_table |>
    (data -> data[data.sex .== "Male", [:race, :age, :count]]) |>
    (df -> unstack(df, :race, :count)) |> # To wide
    (data -> Matrix(data[2:end])) |>
    (A -> A / sum(A)) # conditional joint probabilities
```

Since males and females are matrices (two dimensional arrays), we can combine
these in the third dimension (by sex).

```julia
println(string("Valid Probabilities: ", sum(females) ≈ sum(males) ≈ 1))
pepall5n = cat(females, males, dims = 3) # 3D array
size(pepall5n)
```

The dimensions match 68 age, four race, and two sex categories.

The following functions apply the labels to each dimension and sample based on
the joint distribution.

The idea behind the implementation is:
    (1) For each dimension, sample based on the conditional probability given the
    realization for previous dimensions.
    (2) Continue to do this recursively until every dimension has had a realization.
    (3) Apply labels.

For example, if the realization is (1, 3, 20) it means, choose the first level in
sex (female), the third race category (Latino), and the 20th age category (37 years
old).

```julia
function gen_join_distribution(probabilities, output = Vector{Int}())
    d = ndims(probabilities) # How many dimensions
    iszero(ndims(probabilities)) && return output # If no more dimensions, done
    o = sample(1:size(probabilities, d), # How many options for the next dimensions?
               # Probability weights are given by summing up through the dimensions
               sum.(selectdim.(Ref(probabilities),
                               d,
                               1:size(probabilities, d))) |>
               weights)
    push!(output, o) # Add the observed outcome
    # repeat process given the realization in the previous dimensions
    gen_join_distribution(selectdim(probabilities, d, o), output)
end
labs = [(:sex, levels(cross_table.sex)),
        (:race, levels(cross_table.race)),
        (:age, levels(cross_table.age))]
gen_sex_race_age(joint_distribution, labs) =
    NamedTuple{Tuple(first.(labs))}(getindex.(last.(labs),
                                    gen_join_distribution(joint_distribution)))
```

We can now use our tools to generate 1,000 observations.

```julia
data = map(x -> gen_sex_race_age(pepall5n, labs), 1:1_000) |>
       DataFrame |>
       categorical!
first(data, 5)
```

## Height and Weight

Adult height tends to be normally distributed by groups. Weight tends to be
log-normal and be correlated with height. A good proxy for establishing the
correlation between adult height and weight is the body mass index (BMI) which
is Weibull distributed.

Using the National Health Interview Survey, we can estimate the conditional
distribution of height and weight sex/race groupwise. The normal distribution
is a good fit for human heights for values around three standard deviations from
the mean. Weight is log-normal distributed, but for the conditional distribution
is easier to rely on a Weibull body mass index (BMI) distribution.

We first access the
    2017 National Health Interview Survey (NHIS)
    [documentation](ftp://ftp.cdc.gov/pub/Health_Statistics/NCHS/Dataset_Documentation/NHIS/2017/readme.pdf)
    [Codebook](ftp://ftp.cdc.gov/pub/Health_Statistics/NCHS/Dataset_Documentation/NHIS/2017/samadult_layout.pdf)

```julia
function parserace(race, hisp)
    if hisp ≠ 12
        output = "Latino"
    elseif race == 1
        output = "White"
    elseif race == 2
        output = "Black"
    elseif race == 4
        output = "Asian"
    else
        output = ""
    end
    output
end
nchs = string("ftp://ftp.cdc.gov/pub/Health_Statistics/NCHS/Datasets/",
              "NHIS/",
              "2017/",
              "samadultcsv.zip") |>
    (url -> download(url, joinpath(tempdir(), "NCHS.zip"))) |> # Downloads zip file
    (file -> open_zip(file)["samadult.csv"]) |> # Read the file
    IOBuffer |> # Suitable stream to parse as text file rather than string
    CSV.File |> # Reads coma separated file
    DataFrame |> # Materialize as DataFrame
    # Exclude currently pregnant and invalid BMI records
    (data -> data[ifelse.(ismissing.(data.PREGNOW), true, data.PREGNOW .== 2) .&
                  (1 .≤ data.BMI .≤ 9994),
                  [:SEX, :RACERPI2, :HISPAN_I, :AGE_P, :AHEIGHT, :BMI, :WTFA_SA]]) |>
    (df -> @transform(df,
                      SEX = ifelse.(:SEX .== 1, "Male", "Female"),
                      RACERPI2 = parserace.(:RACERPI2, :HISPAN_I),
                      BMI = :BMI / 100)) |> # Adjust implied decimals
    # Select and rename variables
    (data -> names!(data[[:SEX, :RACERPI2, :AGE_P, :AHEIGHT, :BMI, :WTFA_SA]],
                    [:sex, :race, :age, :height, :bmi, :wts])) |>
    # Ensure valid values for height given documentation
    # Filter races of interest
    (data -> data[(((data.sex .== "Male") .& (59 .≤ data.height .≤ 76)) .|
                   ((data.sex .== "Female") .& (59 .≤ data.height .≤ 70))) .&
                  (data.race .≠ ""),
                  :]) |>
    disallowmissing! |> # Drop missing values
    categorical! # String variables are treated as nominal variables
first(nchs, 5)
```

For fitting the Weibull distributions of BMI by sex and race we can use maximum
likelihood estimation (MLE)

```julia
function mle_Weibull(data, wts)
    x₀ = fill(2.0, 2) # Initial Parameters
    # Set up the objective function, first and second derivatives
    wts = wts ./ sum(wts)
    td = TwiceDifferentiable(x -> Weibull(x[1], x[2]) |>
                                  # Flip sign
                                  (d -> -sum(w * logpdf(d, v) for (w, v) ∈ zip(wts, data))),
                             x₀)
    lx = ones(2) # Lower bound is one for both parameters
    ux = fill(Inf, 2) # No upper bound
    tdc = TwiceDifferentiableConstraints(lx, ux) # Autodiff
    res = optimize(td, tdc, x₀, IPNewton()) # Solve the problem
    Weibull(Optim.minimizer(res)...) # MLE Distribution
end
```

```julia
height_bmi =
    by(nchs,
       [:sex, :race],
       [:bmi, :height, :wts] =>
       data -> (height = fit(Normal, data.height, float(data.wts)),
                bmi = mle_Weibull(data.bmi, data.wts)))
first(height_bmi, 5)
```

The next function uses the groups-wise height and BMI statistics to simulated the
joint distribution of height and weight per gender/race.

```julia
function add_height_weight!(data, height_bmi)
    data.height = 0 # Initialize height
    data.weight = 0 # Initialize weight
    for row in eachrow(height_bmi)
        # Unpack
        sex, race, height, bmi = row.sex, row.race, row.height, row.bmi
        # Identify relevant cases
        idx = (data.sex .== sex) .& (data.race .== race)
        # Sample height for group
        data.height[idx] = round.(Int, rand(height, count(idx)))
        # Go from BMI to pounds
        data.weight[idx] = round.(Int, rand(bmi, count(idx)) .*
                                       data.height[idx].^2 / 703)
    end
    data
end
```

```julia
output = add_height_weight!(data, height_bmi)
first(output, 5)
```

## Verify Approach

Let us see the distribution of covariates to verify our implementation gives
sensible results

The following function shows a scatter plot of weight and height and the BMI density.

```julia
function height_weight(race, sex)
    data = output[(output.sex .== sex) .& (output.race .== race),[:weight, :height]]
    plot(@df(data, scatter(:weight, :height,
                           title = string(race, " ", sex),
                           xlab = "Weight (pounds)",
                           ylab = "Heigh (inches)",
                           legend = :none)),
         @df(data, density(703 * :weight ./ :height.^2,
                           legend = :none,
                           title = "BMI")),
        )
end
```

```julia
height_weight("White", "Male")
```

```julia
height_weight("Black", "Male")
```

```julia
height_weight("Asian", "Male")
```

```julia
height_weight("Latino", "Male")
```

```julia
height_weight("White", "Female")
```

```julia
height_weight("Black", "Female")
```

```julia
height_weight("Asian", "Female")
```

```julia
height_weight("Latino", "Female")
```

We could also have simpler models such as linearly correlated age and weight.
Assume both are normally distributed: Age ~ Normal(70, 10) and
Weight ~ Normal(30, 5) with a covariance of 32. The following code generates
the specified case.

```julia
@views rand(MvNormal([70, 30], [10^2 32.
                                32   5^2]),
            10) |>
    (x -> DataFrame(age = round.(Int, x[1,:]),
                    weight = round.(Int, x[2, :])))
```
